From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Connor O'Brien <connoro@google.com>
Date: Fri, 28 Feb 2020 12:23:14 -0800
Subject: ANDROID: cpufreq: times: Remove
 /proc/uid_concurrent_{active,policy}_time

This removes the portion of commit 4242998e5bdf ("ANDROID: cpufreq:
times: add /proc/uid_concurrent_{active,policy}_time") adding new
files for per-UID stats while preserving a change to skip accounting
for idle tasks.

Bug: 127641090
Signed-off-by: Connor O'Brien <connoro@google.com>
Change-Id: I1e334dcc71201118aa62115fa5247263e545e8d6
---
 .../ABI/testing/procfs-concurrent_time        |  16 --
 drivers/cpufreq/cpufreq_times.c               | 188 +-----------------
 2 files changed, 1 insertion(+), 203 deletions(-)
 delete mode 100644 Documentation/ABI/testing/procfs-concurrent_time

diff --git a/Documentation/ABI/testing/procfs-concurrent_time b/Documentation/ABI/testing/procfs-concurrent_time
deleted file mode 100644
index 55b414289b40..000000000000
--- a/Documentation/ABI/testing/procfs-concurrent_time
+++ /dev/null
@@ -1,16 +0,0 @@
-What:		/proc/uid_concurrent_active_time
-Date:		December 2018
-Contact:	Connor O'Brien <connoro@google.com>
-Description:
-	The /proc/uid_concurrent_active_time file displays aggregated cputime
-	numbers for each uid, broken down by the total number of cores that were
-	active while the uid's task was running.
-
-What:		/proc/uid_concurrent_policy_time
-Date:		December 2018
-Contact:	Connor O'Brien <connoro@google.com>
-Description:
-	The /proc/uid_concurrent_policy_time file displays aggregated cputime
-	numbers for each uid, broken down based on the cpufreq policy
-	of the core used by the uid's task and the number of cores associated
-	with that policy that were active while the uid's task was running.
diff --git a/drivers/cpufreq/cpufreq_times.c b/drivers/cpufreq/cpufreq_times.c
index b07f2ab03469..1a991786917b 100644
--- a/drivers/cpufreq/cpufreq_times.c
+++ b/drivers/cpufreq/cpufreq_times.c
@@ -32,17 +32,11 @@ static DECLARE_HASHTABLE(uid_hash_table, UID_HASH_BITS);
 static DEFINE_SPINLOCK(task_time_in_state_lock); /* task->time_in_state */
 static DEFINE_SPINLOCK(uid_lock); /* uid_hash_table */
 
-struct concurrent_times {
-	atomic64_t active[NR_CPUS];
-	atomic64_t policy[NR_CPUS];
-};
-
 struct uid_entry {
 	uid_t uid;
 	unsigned int max_state;
 	struct hlist_node hash;
 	struct rcu_head rcu;
-	struct concurrent_times *concurrent_times;
 	u64 time_in_state[0];
 };
 
@@ -93,7 +87,6 @@ static struct uid_entry *find_uid_entry_locked(uid_t uid)
 static struct uid_entry *find_or_register_uid_locked(uid_t uid)
 {
 	struct uid_entry *uid_entry, *temp;
-	struct concurrent_times *times;
 	unsigned int max_state = READ_ONCE(next_offset);
 	size_t alloc_size = sizeof(*uid_entry) + max_state *
 		sizeof(uid_entry->time_in_state[0]);
@@ -124,15 +117,9 @@ static struct uid_entry *find_or_register_uid_locked(uid_t uid)
 	uid_entry = kzalloc(alloc_size, GFP_ATOMIC);
 	if (!uid_entry)
 		return NULL;
-	times = kzalloc(sizeof(*times), GFP_ATOMIC);
-	if (!times) {
-		kfree(uid_entry);
-		return NULL;
-	}
 
 	uid_entry->uid = uid;
 	uid_entry->max_state = max_state;
-	uid_entry->concurrent_times = times;
 
 	hash_add_rcu(uid_hash_table, &uid_entry->hash, uid);
 
@@ -228,86 +215,6 @@ static int uid_time_in_state_seq_show(struct seq_file *m, void *v)
 	return 0;
 }
 
-static int concurrent_time_seq_show(struct seq_file *m, void *v,
-	atomic64_t *(*get_times)(struct concurrent_times *))
-{
-	struct uid_entry *uid_entry;
-	int i, num_possible_cpus = num_possible_cpus();
-
-	rcu_read_lock();
-
-	hlist_for_each_entry_rcu(uid_entry, (struct hlist_head *)v, hash) {
-		atomic64_t *times = get_times(uid_entry->concurrent_times);
-
-		seq_put_decimal_ull(m, "", (u64)uid_entry->uid);
-		seq_putc(m, ':');
-
-		for (i = 0; i < num_possible_cpus; ++i) {
-			u64 time = nsec_to_clock_t(atomic64_read(&times[i]));
-
-			seq_put_decimal_ull(m, " ", time);
-		}
-		seq_putc(m, '\n');
-	}
-
-	rcu_read_unlock();
-
-	return 0;
-}
-
-static inline atomic64_t *get_active_times(struct concurrent_times *times)
-{
-	return times->active;
-}
-
-static int concurrent_active_time_seq_show(struct seq_file *m, void *v)
-{
-	if (v == uid_hash_table) {
-		seq_put_decimal_ull(m, "cpus: ", num_possible_cpus());
-		seq_putc(m, '\n');
-	}
-
-	return concurrent_time_seq_show(m, v, get_active_times);
-}
-
-static inline atomic64_t *get_policy_times(struct concurrent_times *times)
-{
-	return times->policy;
-}
-
-static int concurrent_policy_time_seq_show(struct seq_file *m, void *v)
-{
-	int i;
-	struct cpu_freqs *freqs, *last_freqs = NULL;
-
-	if (v == uid_hash_table) {
-		int cnt = 0;
-
-		for_each_possible_cpu(i) {
-			freqs = all_freqs[i];
-			if (!freqs)
-				continue;
-			if (freqs != last_freqs) {
-				if (last_freqs) {
-					seq_put_decimal_ull(m, ": ", cnt);
-					seq_putc(m, ' ');
-					cnt = 0;
-				}
-				seq_put_decimal_ull(m, "policy", i);
-
-				last_freqs = freqs;
-			}
-			cnt++;
-		}
-		if (last_freqs) {
-			seq_put_decimal_ull(m, ": ", cnt);
-			seq_putc(m, '\n');
-		}
-	}
-
-	return concurrent_time_seq_show(m, v, get_policy_times);
-}
-
 void cpufreq_task_times_init(struct task_struct *p)
 {
 	unsigned long flags;
@@ -400,14 +307,9 @@ void cpufreq_acct_update_power(struct task_struct *p, u64 cputime)
 {
 	unsigned long flags;
 	unsigned int state;
-	unsigned int active_cpu_cnt = 0;
-	unsigned int policy_cpu_cnt = 0;
-	unsigned int policy_first_cpu;
 	struct uid_entry *uid_entry;
 	struct cpu_freqs *freqs = all_freqs[task_cpu(p)];
-	struct cpufreq_policy *policy;
 	uid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));
-	int cpu = 0;
 
 	if (!freqs || is_idle_task(p) || p->flags & PF_EXITING)
 		return;
@@ -425,42 +327,6 @@ void cpufreq_acct_update_power(struct task_struct *p, u64 cputime)
 	if (uid_entry && state < uid_entry->max_state)
 		uid_entry->time_in_state[state] += cputime;
 	spin_unlock_irqrestore(&uid_lock, flags);
-
-	rcu_read_lock();
-	uid_entry = find_uid_entry_rcu(uid);
-	if (!uid_entry) {
-		rcu_read_unlock();
-		return;
-	}
-
-	for_each_possible_cpu(cpu)
-		if (!idle_cpu(cpu))
-			++active_cpu_cnt;
-
-	atomic64_add(cputime,
-		     &uid_entry->concurrent_times->active[active_cpu_cnt - 1]);
-
-	policy = cpufreq_cpu_get(task_cpu(p));
-	if (!policy) {
-		/*
-		 * This CPU may have just come up and not have a cpufreq policy
-		 * yet.
-		 */
-		rcu_read_unlock();
-		return;
-	}
-
-	for_each_cpu(cpu, policy->related_cpus)
-		if (!idle_cpu(cpu))
-			++policy_cpu_cnt;
-
-	policy_first_cpu = cpumask_first(policy->related_cpus);
-	cpufreq_cpu_put(policy);
-
-	atomic64_add(cputime,
-		     &uid_entry->concurrent_times->policy[policy_first_cpu +
-							  policy_cpu_cnt - 1]);
-	rcu_read_unlock();
 }
 
 static int cpufreq_times_get_index(struct cpu_freqs *freqs, unsigned int freq)
@@ -512,14 +378,6 @@ void cpufreq_times_create_policy(struct cpufreq_policy *policy)
 		all_freqs[cpu] = freqs;
 }
 
-static void uid_entry_reclaim(struct rcu_head *rcu)
-{
-	struct uid_entry *uid_entry = container_of(rcu, struct uid_entry, rcu);
-
-	kfree(uid_entry->concurrent_times);
-	kfree(uid_entry);
-}
-
 void cpufreq_task_times_remove_uids(uid_t uid_start, uid_t uid_end)
 {
 	struct uid_entry *uid_entry;
@@ -533,7 +391,7 @@ void cpufreq_task_times_remove_uids(uid_t uid_start, uid_t uid_end)
 			hash, uid_start) {
 			if (uid_start == uid_entry->uid) {
 				hash_del_rcu(&uid_entry->hash);
-				call_rcu(&uid_entry->rcu, uid_entry_reclaim);
+				kfree_rcu(uid_entry, rcu);
 			}
 		}
 	}
@@ -579,55 +437,11 @@ static const struct proc_ops uid_time_in_state_fops = {
 	.proc_release	= seq_release,
 };
 
-static const struct seq_operations concurrent_active_time_seq_ops = {
-	.start = uid_seq_start,
-	.next = uid_seq_next,
-	.stop = uid_seq_stop,
-	.show = concurrent_active_time_seq_show,
-};
-
-static int concurrent_active_time_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &concurrent_active_time_seq_ops);
-}
-
-static const struct proc_ops concurrent_active_time_fops = {
-	.proc_open	= concurrent_active_time_open,
-	.proc_read	= seq_read,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= seq_release,
-};
-
-static const struct seq_operations concurrent_policy_time_seq_ops = {
-	.start = uid_seq_start,
-	.next = uid_seq_next,
-	.stop = uid_seq_stop,
-	.show = concurrent_policy_time_seq_show,
-};
-
-static int concurrent_policy_time_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &concurrent_policy_time_seq_ops);
-}
-
-static const struct proc_ops concurrent_policy_time_fops = {
-	.proc_open	= concurrent_policy_time_open,
-	.proc_read	= seq_read,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= seq_release,
-};
-
 static int __init cpufreq_times_init(void)
 {
 	proc_create_data("uid_time_in_state", 0444, NULL,
 			 &uid_time_in_state_fops, NULL);
 
-	proc_create_data("uid_concurrent_active_time", 0444, NULL,
-			 &concurrent_active_time_fops, NULL);
-
-	proc_create_data("uid_concurrent_policy_time", 0444, NULL,
-			 &concurrent_policy_time_fops, NULL);
-
 	return 0;
 }
 
