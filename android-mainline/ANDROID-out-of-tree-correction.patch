From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Matthias Maennich <maennich@google.com>
Date: Mon, 4 May 2020 01:37:30 +0200
Subject: ANDROID: out-of-tree correction

commit dd5c9369672e ("Merge 7e63420847ae ("Merge tag 'acpi-5.7-rc1-2' of
git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm") into
android-mainline") introduced a difference to the upstream tree by
discarding all changes done in include/linux/fsnotify.h.

This can be seen when comparing the difference that should have been
introduce by the merge

  $ git diff 5364abc57993..7e63420847ae -- include/linux/fsnotify.h
    1 file changed, 58 insertions(+), 80 deletions(-)

... and the actual difference introduced ...

  $ git diff dd5c9369672e^1..dd5c9369672e -- include/linux/fsnotify.h
    <empty>

Add this correction patch to track the out-of-tree difference.

Signed-off-by: Matthias Maennich <maennich@google.com>
Change-Id: I0bc091a899d474124627eb8edf5123adf3071231
---
 include/linux/fsnotify.h | 136 +++++++++++++++++++++------------------
 1 file changed, 74 insertions(+), 62 deletions(-)

diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -18,63 +18,29 @@
 #include <linux/bug.h>
 
 /*
- * Notify this @dir inode about a change in a child directory entry.
- * The directory entry may have turned positive or negative or its inode may
- * have changed (i.e. renamed over).
+ * Notify this @dir inode about a change in the directory entry @dentry.
  *
  * Unlike fsnotify_parent(), the event will be reported regardless of the
  * FS_EVENT_ON_CHILD mask on the parent inode.
  */
-static inline void fsnotify_name(struct inode *dir, __u32 mask,
-				 struct inode *child,
-				 const struct qstr *name, u32 cookie)
+static inline int fsnotify_dirent(struct inode *dir, struct dentry *dentry,
+				  __u32 mask)
 {
-	fsnotify(dir, mask, child, FSNOTIFY_EVENT_INODE, name, cookie);
-	/*
-	 * Send another flavor of the event without child inode data and
-	 * without the specific event type (e.g. FS_CREATE|FS_IS_DIR).
-	 * The name is relative to the dir inode the event is reported to.
-	 */
-	fsnotify(dir, FS_DIR_MODIFY, dir, FSNOTIFY_EVENT_INODE, name, 0);
-}
-
-static inline void fsnotify_dirent(struct inode *dir, struct dentry *dentry,
-				   __u32 mask)
-{
-	fsnotify_name(dir, mask, d_inode(dentry), &dentry->d_name, 0);
+	return fsnotify(dir, mask, d_inode(dentry), FSNOTIFY_EVENT_INODE,
+			&dentry->d_name, 0);
 }
 
 /*
- * Simple wrappers to consolidate calls fsnotify_parent()/fsnotify() when
- * an event is on a file/dentry.
+ * Simple wrapper to consolidate calls fsnotify_parent()/fsnotify() when
+ * an event is on a path.
  */
-static inline void fsnotify_dentry(struct dentry *dentry, __u32 mask)
+static inline int fsnotify_path(struct inode *inode, const struct path *path,
+				__u32 mask)
 {
-	struct inode *inode = d_inode(dentry);
-
-	if (S_ISDIR(inode->i_mode))
-		mask |= FS_ISDIR;
-
-	fsnotify_parent(dentry, mask, inode, FSNOTIFY_EVENT_INODE);
-	fsnotify(inode, mask, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
-}
-
-static inline int fsnotify_file(struct file *file, __u32 mask)
-{
-	const struct path *path = &file->f_path;
-	struct inode *inode = file_inode(file);
-	int ret;
+	int ret = fsnotify_parent(path->dentry, mask, path, FSNOTIFY_EVENT_PATH);
 
-	if (file->f_mode & FMODE_NONOTIFY)
-		return 0;
-
-	if (S_ISDIR(inode->i_mode))
-		mask |= FS_ISDIR;
-
-	ret = fsnotify_parent(path->dentry, mask, path, FSNOTIFY_EVENT_PATH);
 	if (ret)
 		return ret;
-
 	return fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
 }
 
@@ -82,16 +48,19 @@ static inline int fsnotify_file(struct file *file, __u32 mask)
 static inline int fsnotify_perm(struct file *file, int mask)
 {
 	int ret;
+	const struct path *path = &file->f_path;
+	struct inode *inode = file_inode(file);
 	__u32 fsnotify_mask = 0;
 
+	if (file->f_mode & FMODE_NONOTIFY)
+		return 0;
 	if (!(mask & (MAY_READ | MAY_OPEN)))
 		return 0;
-
 	if (mask & MAY_OPEN) {
 		fsnotify_mask = FS_OPEN_PERM;
 
 		if (file->f_flags & __FMODE_EXEC) {
-			ret = fsnotify_file(file, FS_OPEN_EXEC_PERM);
+			ret = fsnotify_path(inode, path, FS_OPEN_EXEC_PERM);
 
 			if (ret)
 				return ret;
@@ -100,7 +69,10 @@ static inline int fsnotify_perm(struct file *file, int mask)
 		fsnotify_mask = FS_ACCESS_PERM;
 	}
 
-	return fsnotify_file(file, fsnotify_mask);
+	if (S_ISDIR(inode->i_mode))
+		fsnotify_mask |= FS_ISDIR;
+
+	return fsnotify_path(inode, path, fsnotify_mask);
 }
 
 /*
@@ -140,8 +112,10 @@ static inline void fsnotify_move(struct inode *old_dir, struct inode *new_dir,
 		mask |= FS_ISDIR;
 	}
 
-	fsnotify_name(old_dir, old_dir_mask, source, old_name, fs_cookie);
-	fsnotify_name(new_dir, new_dir_mask, source, new_name, fs_cookie);
+	fsnotify(old_dir, old_dir_mask, source, FSNOTIFY_EVENT_INODE, old_name,
+		 fs_cookie);
+	fsnotify(new_dir, new_dir_mask, source, FSNOTIFY_EVENT_INODE, new_name,
+		 fs_cookie);
 
 	if (target)
 		fsnotify_link_count(target);
@@ -196,13 +170,12 @@ static inline void fsnotify_create(struct inode *inode, struct dentry *dentry)
  * Note: We have to pass also the linked inode ptr as some filesystems leave
  *   new_dentry->d_inode NULL and instantiate inode pointer later
  */
-static inline void fsnotify_link(struct inode *dir, struct inode *inode,
-				 struct dentry *new_dentry)
+static inline void fsnotify_link(struct inode *dir, struct inode *inode, struct dentry *new_dentry)
 {
 	fsnotify_link_count(inode);
 	audit_inode_child(dir, new_dentry, AUDIT_TYPE_CHILD_CREATE);
 
-	fsnotify_name(dir, FS_CREATE, inode, &new_dentry->d_name, 0);
+	fsnotify(dir, FS_CREATE, inode, FSNOTIFY_EVENT_INODE, &new_dentry->d_name, 0);
 }
 
 /*
@@ -246,7 +219,15 @@ static inline void fsnotify_rmdir(struct inode *dir, struct dentry *dentry)
  */
 static inline void fsnotify_access(struct file *file)
 {
-	fsnotify_file(file, FS_ACCESS);
+	const struct path *path = &file->f_path;
+	struct inode *inode = file_inode(file);
+	__u32 mask = FS_ACCESS;
+
+	if (S_ISDIR(inode->i_mode))
+		mask |= FS_ISDIR;
+
+	if (!(file->f_mode & FMODE_NONOTIFY))
+		fsnotify_path(inode, path, mask);
 }
 
 /*
@@ -254,7 +235,15 @@ static inline void fsnotify_access(struct file *file)
  */
 static inline void fsnotify_modify(struct file *file)
 {
-	fsnotify_file(file, FS_MODIFY);
+	const struct path *path = &file->f_path;
+	struct inode *inode = file_inode(file);
+	__u32 mask = FS_MODIFY;
+
+	if (S_ISDIR(inode->i_mode))
+		mask |= FS_ISDIR;
+
+	if (!(file->f_mode & FMODE_NONOTIFY))
+		fsnotify_path(inode, path, mask);
 }
 
 /*
@@ -262,19 +251,23 @@ static inline void fsnotify_modify(struct file *file)
  */
 static inline void fsnotify_open(struct file *file)
 {
+	const struct path *path = &file->f_path;
 	struct path lower_path;
+	struct inode *inode = file_inode(file);
 	__u32 mask = FS_OPEN;
 
+	if (S_ISDIR(inode->i_mode))
+		mask |= FS_ISDIR;
 	if (file->f_flags & __FMODE_EXEC)
 		mask |= FS_OPEN_EXEC;
 
 	if (path->dentry->d_op && path->dentry->d_op->d_canonical_path) {
 		path->dentry->d_op->d_canonical_path(path, &lower_path);
-		fsnotify_parent(lower_path.dentry, mask, NULL, FSNOTIFY_EVENT_PATH);
+		fsnotify_parent(lower_path.dentry, mask, &lower_path, FSNOTIFY_EVENT_PATH);
 		fsnotify(lower_path.dentry->d_inode, mask, &lower_path, FSNOTIFY_EVENT_PATH, NULL, 0);
 		path_put(&lower_path);
 	}
-	fsnotify_file(file, mask);
+	fsnotify_path(inode, path, mask);
 }
 
 /*
@@ -282,10 +275,16 @@ static inline void fsnotify_open(struct file *file)
  */
 static inline void fsnotify_close(struct file *file)
 {
-	__u32 mask = (file->f_mode & FMODE_WRITE) ? FS_CLOSE_WRITE :
-						    FS_CLOSE_NOWRITE;
+	const struct path *path = &file->f_path;
+	struct inode *inode = file_inode(file);
+	fmode_t mode = file->f_mode;
+	__u32 mask = (mode & FMODE_WRITE) ? FS_CLOSE_WRITE : FS_CLOSE_NOWRITE;
 
-	fsnotify_file(file, mask);
+	if (S_ISDIR(inode->i_mode))
+		mask |= FS_ISDIR;
+
+	if (!(file->f_mode & FMODE_NONOTIFY))
+		fsnotify_path(inode, path, mask);
 }
 
 /*
@@ -293,7 +292,14 @@ static inline void fsnotify_close(struct file *file)
  */
 static inline void fsnotify_xattr(struct dentry *dentry)
 {
-	fsnotify_dentry(dentry, FS_ATTRIB);
+	struct inode *inode = dentry->d_inode;
+	__u32 mask = FS_ATTRIB;
+
+	if (S_ISDIR(inode->i_mode))
+		mask |= FS_ISDIR;
+
+	fsnotify_parent(dentry, mask, inode, FSNOTIFY_EVENT_INODE);
+	fsnotify(inode, mask, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
 }
 
 /*
@@ -302,6 +308,7 @@ static inline void fsnotify_xattr(struct dentry *dentry)
  */
 static inline void fsnotify_change(struct dentry *dentry, unsigned int ia_valid)
 {
+	struct inode *inode = dentry->d_inode;
 	__u32 mask = 0;
 
 	if (ia_valid & ATTR_UID)
@@ -322,8 +329,13 @@ static inline void fsnotify_change(struct dentry *dentry, unsigned int ia_valid)
 	if (ia_valid & ATTR_MODE)
 		mask |= FS_ATTRIB;
 
-	if (mask)
-		fsnotify_dentry(dentry, mask);
+	if (mask) {
+		if (S_ISDIR(inode->i_mode))
+			mask |= FS_ISDIR;
+
+		fsnotify_parent(dentry, mask, inode, FSNOTIFY_EVENT_INODE);
+		fsnotify(inode, mask, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
+	}
 }
 
 #endif	/* _LINUX_FS_NOTIFY_H */
